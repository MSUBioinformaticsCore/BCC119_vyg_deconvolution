---
title: "Estimate immune cell proportions in tumor samples"
author: "Stephanie Hickey"
date: `r Sys.Date()`
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
```

```{css, echo=FALSE}
pre, code {white-space:pre !important; overflow-x:auto}
```

# Project Summary

Here we use single-cell RNA-seq data from primary osteosarcoma in 6 treatment-naÃ¯ve dogs ([Ammons et al, Commun Biol. 2024 Apr 24](https://www.nature.com/articles/s42003-024-06182-w)) as a reference data set to estimate immune cell proportions in bulk tumor samples using parallel methods [MuSiC](https://xuranw.github.io/MuSiC/articles/MuSiC.html) and [SCDC]().

The following cell types are included in the reference data:

  1. TAM    
  2. T cell   
  3. Endothelial cell   
  4. Osteoblast   
  5. T_cycling    
  6. Hypoxic_osteoblast   
  7. Cycling_OC   
  8. Osteoblast_cycling   
  9. B cell   
  10. Neutrophil    
  11. IFN-TAM   
  12. CD320_OC    
  13. Fibroblast    
  14. T_IFN   
  15. IFN-osteoblast    
  16. DC    
  17. NK    
  18. Mature_OC   
  19. Mast cell   
  20. TIM   

Both MuSiC and SCDC take advantage of multi-subject reference data sets by appropriately weighting genes showing cross-subject and cross-cell consistency.

barplot one tool
```{r}
# stacked bar
res_df = as.data.frame(music.res$Est.prop.weighted)
res_df$Samples =rownames(res_df)

# res_df = rename(res_df, Samples = "X")

music_long = 
  res_df %>%
  pivot_longer(cols = -Samples,
               names_to = "CellType", 
               values_to = "Proportion") %>%
  mutate(Tool = "MuSiC",
         CellType = gsub(" ", ".", CellType))

# http://vrl.cs.brown.edu/color
col20 = c("#4f8c9d", "#b9cf84", "#a84d64", "#7ed4d8", "#42455e", "#96ea4e", "#4b3596", "#39eec0", "#f92e5d", "#638123", "#5010c8", "#e4b5ff", "#b34a12", "#f1bb99", "#8d6cf6", "#20f53d", "#ea2db9", "#5281e3", "#31a62e", "#fd8992")

ggplot(music_long, 
       aes(x = Samples, 
           y = Proportion, 
           fill = CellType)) +
  geom_col() +
  scale_fill_manual(values = col20) +
  theme_classic() +
  coord_flip()

ggsave(file = paste0(results.dir, "/music_proportions.png"))
```

all

## Summary
```{r}
all_long = rbind(music_long, 
                 music.qc_long, 
                 scdc_long,
                 fake_secret) 
                 #secret_long)

#rand_seq_empirical <- quantile(music_long$Proportion, 
                               #probs = runif(length(music_long$Proportion)))

#fake_secret = 
  #music_long %>%
  #mutate(Tool = "Secret",
        #Proportion = rand_seq_empirical)

# plot by tool, facet sample?
ggplot(all_long, 
       aes(x = Tool, 
           y = Proportion, 
           fill = CellType)) +
  geom_col() +
  scale_fill_manual(values = col20) +
  theme_classic() +
  coord_flip() +
  facet_wrap(~Samples)

ggsave(file = paste0(results.dir, "/all_tool_proportions.png"),
       width = 15,
       height = 10)

# pairwise correlations
tools_wide = 
  all_long %>%
  pivot_wider(id_cols = c(Samples, CellType), 
              names_from = Tool, 
              values_from = Proportion)

write.csv(tools_wide, 
          file = paste0(results.dir, "/proportions_all_tools.csv"),
          row.names = FALSE)

tools_wide = 
  tools_wide %>%
  select(-CellType)

pairwise_correlations <- function(df, group_var) {
  
  
  df %>%
    # Group by the group_var (can be any variable like 'group', 'ID', etc.)
    group_by({{ group_var }}) %>%
    # Nest data by group to iterate over each group separately
    nest() %>%
    # Apply pairwise correlation within each group
    mutate(cor_results = map(data, ~{
      data <- .x
      # Get variable names
      var_names <- colnames(data)
      # Get all pairwise combinations of variables
      combs <- combn(var_names, 2, simplify = FALSE)
      
      # Perform pairwise correlations for all combinations
      map_dfr(combs, function(pair) {
        cor_test <- cor.test(data[[pair[1]]], data[[pair[2]]], use = "complete.obs")
        tibble(
          var1 = pair[1],
          var2 = pair[2],
          correlation = cor_test$estimate,
          p_value = cor_test$p.value
        )
      })
    })) %>%
    # Unnest the correlation results to get a flat table
    unnest(cor_results)
}

pw.result <- pairwise_correlations(tools_wide, group_var = Samples)

library(RColorBrewer)
library(hrbrthemes)
library(patchwork)

hm_list = list()
rng = range(pw.result$correlation)

# no x y labs
# no grid lines
# vertical x axis lab
# smaller title
# print rounded number in box

for(s in unique(pw.result$Samples)){
  
  hm_list[[s]] = 
    pw.result %>%
    filter(Samples == s) %>%
    mutate(CorrPrint = round(correlation, 2)) %>%
    ggplot(aes(var1, var2, fill= correlation)) + 
      geom_tile(color = "white") +
      geom_text(aes(label = CorrPrint), 
                color = "white",
                size = 3) +
      coord_equal() +
      scale_fill_gradientn(colors = brewer.pal(9, "YlOrRd"),
                           limits=c(floor(rng[1]), ceiling(rng[2]))) +
      ggtitle(s) +
      labs(x = NULL, y = NULL) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1),
            panel.grid = element_blank(),
            plot.title = element_text(size = 10, face = "bold")) 
}

wrap_plots(hm_list) + guide_area() + plot_layout(guides = 'collect')
ggsave(paste0(results.dir, "/correlation_heatmap.png"),
       width = 15,
       height = 12)
```


## Session info
```{r}
sessionInfo()
```
